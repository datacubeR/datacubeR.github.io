---
title: "Github para Data Science"
subheadline: "Github Basics y un poco más."
teaser: "Control de Versiones en Ciencia de Datos"
# layout: page-fullwidth
usemathjax: true
category: quick
header: no
image:
    thumb: github/github.png
tags:
- python
- tutorial
published: false
---

# Control de Versiones

![picture of me]({{ site.urlimg }}github/github.png){: .left .show-for-large-up .hide-for-print width="500"}
![picture of me]({{ site.urlimg }}github/github.png){: .center .hide-for-large-up width="250"}

Github es una plataforma que permite almacenar código en la nube de manera que se pueda contribuir de manera colaborativa.  <!--more-->Github está basado en GIT que es el software creado para llevar un control de versiones de un documento. Si bien es cierto GIT se puede utilizar para llevar registro de cualquier tipo de archivo, éste se ha popularizado para el desarrollo de software libre. Hoy en día no se puede ser desarrollador de software sin saber GIT/Github. Es por eso que para la ciencia de datos, que es un campo que cada vez más tiene que ver con el desarrollo de software se hace esencial saber lo básico y yo diría que un poquito más.

Lamentablemente, son pocos las personas que entienden a cabalidad como funciona GIT. Y como al final tiene tantos comandos (que muchas veces hay que correr en terminal), mucha gente le tiene mucho miedo y sabe los comandos básicos sin entenderlos. Este Meme refleja demasiado bien el uso común de Github (y debo decir, que pasa en muchos desarrolladores experimentados también):

![picture of me]({{ site.urlimg }}github/meme.png){: .center}

Bueno entonces cómo usamos GIT. Yo creo que está lleno de tutoriales de cómo aprender a usarlo. Pero creo que lo mejor es entender cómo funciona con un ejemplo. Para ello voy a crear un Repositorio desde cero y mostrar cómo se trabaja con él.

## Creando un Repo en Github.

Primero que todo tenemos que ir a nuestro perfil de Github y tenemos la opción de crear un Nuevo Repositorio:

![picture of me]({{ site.urlimg }}github/new_repo.png){: .center}
![picture of me]({{ site.urlimg }}github/new_repo_2.png){: .center}

En este caso este es mi página de inicio, y si se escoge la pestaña *Repositories* y clickeas en *New*, se llega a algo como esto:

![picture of me]({{ site.urlimg }}github/repo_2.png){: .center}

Cuando se es primera vez que se trabaja con Github, mi recomendación es sólo colocar el nombre, en este caso *tutorial_github*, dejarlo como un Repo Público y clickear en *Create repository*. La razón por la cual hacer esto es porque si se no se escoge nada para comenzar el repositorio el propio github te entrega instrucciones de cómo proseguir en el proceso.

{% include alert warning='Cuando un Repositorio es público implica que cualquier persona puede verlo. En caso de que haya código que no quieres que sea compartido con alguien más, entonces mi recomendación es dejarlo privado' %}

![picture of me]({{ site.urlimg }}github/new_repo3.png){: .center}

Al terminar la construcción del Repo nos entrega instrucciones las cuales pueden seguir para continuar con el proceso. Esto es lo primero que tenemos que entender. Lo que acabamos de hacer es crear nuestro Repo Remoto, lo cual normalmente Github llama **origin**. Nuestro Repo remoto va a ser el backup que va a vivir en la Nube específicamente en Github. Este remoto por sí solo no es útil, este debe ser sincronizado con nuestro Repo Local. Y un Repo Local no es más que una manera fancy de denominar una carpeta. La diferencia es que esta carpeta va a ir siendo trackeada, y se guardaran todas las distintas versiones que nosotros queramos de nuestros documentos.

El control de versiones nos permitirá evitar carpetas llenas de múltiples copias de nuestro trabajo como esto:

![picture of me]({{ site.urlimg }}github/version_control.png){: .center}

{% include alert tip='A continuación voy a ir mostrando el paso a paso en mi maquina con Ubuntu. Seguir estos pasos es exactamente igual en los distintos sistemas operativos. La ventaja de usar Ubuntu y en mi caso el Shell ZSH es que tiene algunos elementos que me ayudarán a entender mejor el estado de mi Repo.'%}


# Creando Nuestro Repo Local


Crear nuestro Repo Local es muy sencillo, sólo tienes que asegurarte de tener instalado GIT desde [acá](https://git-scm.com/downloads). Y en la carpeta de interés abre la línea de comandos y ejecuta:

```shell
$ git init
```

{% include alert info='El comando `git init` lo único que hace es crear una carpeta oculta llamada `.git` que lo que hará es ir almacenando automáticamente distintas versiones de tus documentos. '%}

Ahora nuestro Repo Local es la carpeta de trabajo que utilizaremos y se crea automáticamente la Rama Master que es como la versión oficial en la que trabajaremos:

![picture of me]({{ site.urlimg }}github/git_init.png){: .center}

Pero para que este repo local, se sincronice con el Repo Remoto que tenemos en Github tenemos que ejecutar lo siguiente:

```shell
$ git remote add origin git@github.com:datacubeR/tutorial_github.git
```
donde `git@github.com:datacubeR/tutorial_github.git` corresponde a la localización de nuestro Repo Remoto. Github ofrece dos versiones de la localización una HTTPS y una SSH. Mi recomendación es ir por la SSH ya que poco a poco Github está quitando soporte a la HTTPS. Además la versión SSH permite que cada vez que hagas commit y push no tengas que colocar tu clave de acceso, lo cual lo hace muy cómodo y de hecho es más seguro.

{% include alert tip='Yo la verdad es que setié mi configuración SSH hace tiempo y no recuerdo bien cómo lo hice. Pero si buscan en Youtube hay varios tutoriales de cómo hacer el proceso, que es opcional, pero sugiero realizarlo.'%}

# Esquema de trabajo en Github

Es tan popular el uso de Github que se han desarrollado distintas estrategias de trabajo para trabajar en él. Yo tuve la suerte de trabajar en Jooycar, que seguía bastantes buenas prácticas de desarrollo de software y pude aprender siento que bastante bien cómo trabajar con Github. 

![picture of me]({{ site.urlimg }}github/gitflow.png){: .center}

Básicamente la idea es seguir una lógica de Ramas, donde la Rama Master (recientemente llamada main, pero yo y la mayoría sigue llamandola master, porque suena más cool) es la versión principal de tu código. La idea que el código que vive en Master sea el código funcional, libre de bugs. Y cualquier trabajo se haga en ramas paralelas que no rompan master. Una vez que las ramas paralelas (o de features) estén probadas y se sabe que funcionan como se esperan, se unirán a Master. 
En github hay harta terminología que es importante entender antes de usarlo:

* Ramas: Son las distintas versiones del trabajo realizado. La rama principal es Master o Main.
* Ramas Secundarias. Versiones donde se realizan las pruebas para evitar romper Master, que normalmente es el código productivo libre de Bugs.
* Commits. Corresponden a cada uno de los puntitos. Cada punto es un **Save**. Es decir por cada commits hay cambios en el código, pueden ser adiciones, sustracciones o modificaciones del código.
* Push: Se refiere a guardar nuestros commits locales en Github.

# Nuestro Primer Commit

Para realizar el commit entonces es necesario hacer nuestros primeros cambios: Creemos entonces un archivo llamado `main.py` y creemos lo siguiente:

```python
import pandas as pd
import numpy as np

def detectar_nulos(df):
    return df.isnull().sum()

```
{: title="main.py"}

Luego entonces debemos utilizar los siguientes comandos:

```shell
$ git add .
```
Este comando agregará todos los archivos (es el significado del punto) al <mark>Stage Area</mark>. Esta área se utiliza para indicarle a git cuáles son los archivos que van a ser parte del commit. Obviamente no es necesario juntarlos todos en el común. También se puede usar **git add** para ir agregándo sólo los necesarios (pero normalmente todos los archivos modificados son parte del commit).

```shell
git status
```

**git status** nos dirá cuales son los archivos que están actualmente siendo trackeados.

```shell
$ git commit -m 'Mi primer Commit'
```
Finalmente **git commit** será el encargado de guardar una versión en GIT. Esta versión va a acompañada de un mensaje, el que indica en qué se trabajó durante dicho commit. De esta manera en caso de tener errores en el futuro y se quiera volver a versiones anteriores se tiene el comentario como referencia para encontrar el commit indicado.

{% include alert info='Es necesario recordar que un commit sólo genera una versión local en nuestro repositorio. Es decir sólo yo puedo verlo. Si mi avance puede ser de ayuda a mis compañeros entonces tengo que sincronozar estos cambios con Github. De esta manera todo el equipo va a poder mirar este código.'%}

## Nuestro Primer Push

Para llevar el código a Github es necesario hacer un push:

```shell
$ git push
```

Es importante entender que este comando fallará la primera vez que se ejecute. Ya que GIT inicialmente no entiende con qué ramas remotas está sincronizado. Mi recomendación es que una vez usado git push, Github indicará que no es el comando indicado y te dirá cuál es el apropiado. Esto se debe hacer en el primer commit de cada rama. Luego de eso git push es suficiente.

Todos nuestros cambios se ven en Github de la siguiente forma:

{% include alert success='Normalmente esto es casi todo lo que cualquier persona que dice saber Git efectivamente sabe. Quizás algunos dicen conocer git pull. Pero la verdad es que eso no es del todo cierto y voy a explicar git pull en detalle más adelante.'%}

# Trabajo en Ramas

Si bien es cierto siempre se puede ir trabajando en Master, esto constituye una muy mala práctica. Como hemos dicho anteriormente, se considera Master como la versión productiva del código, por lo tanto, no puede ser alterado por nada que no sea por código debidamente probado. En el caso de trabajar en cualquier cosa que pudiera romper el código productivo (esto significa básicamente todo lo que no sea el código final), es necesario trabajar en Ramas.

```shell
git checkout -b nueva-rama
```

Este comando creará una nueva rama e inmediatamente se cambiará a ella. El flag `-b` es para indicar que la rama creada se llamará `nueva-rama`. Existen varias convenciones para el nombramiento de las nuevas ramas, normalmente se antepone un `feature` cuando se está trabajando en una nueva funcionalidad del código o `hot-fix` cuando se quiere solucionar rápidamente un bug encontrado en producción. Pero la verdad la convención de nombres va a depender del equipo. Lo importante es que el nombre de la rama sea representativo del trabajo realizado.

La rama corresponde a una versión paralela, la buena práctica dice que las nuevas ramas debieran salir principalmente de Master, pero siempre se pueden crear subramas que partan del trabajo realizado de un compañero. Entre más anidadas estén las ramas más complicado es volver a unirla en Master, por lo que si bien, es posible, se desaconseja en la medida de lo posible.

Al crear una rama, todo funciona igual, salvo que los commits se irán haciendo en la nueva rama, creando una historia alternativa a Master. En este caso cuando se queramos hacer un push tendremos que definir la primera vez cuales es la rama correspondiente en Github.

Apenas creemos un nuevo commit en una rama no Master, Github nos sugerirá que realicemos un Pull Request (PR para los amigos). Entender un Pull Request y todas las funcionalidades que tiene da para un artículo entero, pero en sencillo, un Pull Request es una instancia de revisión, en la que normalmente un Programador/Data Scientist con más experiencia, revisará el código (aunque también puede ser un par). De esta manera varios pares de ojos revisan que:

* No se introduzcan bugs a la rama productiva.
* Pueden sugerir mejores manera de abordar una solución.
* Pueden corregir y dar feedback del trabajo realizado.

Al crear el PR se debe colocar un título adhoc al trabajo realizado más una descripción. El PR tiene la posibilidad de ser comentado (para sugerir feedback), aprobado directamente en caso de no tener problemas, o se pueden solicitar cambios que deben ser realizados antes de la aprobación. En caso de que el PR no sea aprobado no podrá fusionarse con Master (en estricto rigor los settings por defecto de Github te dejan hacer el merge, pero no se debería. En cualquier caso Github permite bloquear los push a Master permitiéndolos sólo mediante PRs aprobados, esta funcionalidad está disponible en todos los Repos Públicos, o en Repos Privados que sean Cuenta Pro o Enterprise.)

# Sincronización del Repo Remoto con el Repo Local

Probablemente dirás no necesito entender esto, basta con usar git pull. Pero sabías que hay dos estrategias de Pull, y es muy probable que la estrategia por defecto no sea la mejor para ti?

Si no quieres pensar nada, y no te interesa entender qué pasa en GIT usa git pull y no te cuestiones nada. Pero existe una segunda estrategia que se llama Rebase, que diferencia un usuario común de uno que entiende un poquito más de GIT.

git pull es un comando compuesto, que está compuesto por git fetch + git merge o git rebase dependiendo de cómo lo uses.












