---
permalink: /github/ 
title: "Github para Data Science"
subheadline: "Github Basics y un poco m치s."
teaser: "Control de Versiones en Ciencia de Datos"
# layout: page-fullwidth
usemathjax: true
category: quick
header: no
image:
    thumb: github/github.png
tags:
- python
- tutorial
published: true
---

![picture of me]({{ site.urlimg }}github/github.png){: .left .show-for-large-up .hide-for-print width="250"}
![picture of me]({{ site.urlimg }}github/github.png){: .center .hide-for-large-up width="500"}

Si eres Data Scientist es muy probable que nunca hayas usado GIT/Github. No te culpo, no somos completamente desarrolladores y quiz치s muchos de ustedes (al igual que yo) ni siquiera tenemos un background en Ciencias de la Computaci칩n. Entonces la pregunta es, 쯇or qu칠 deber칤amos usarlo?<!--more-->

Github es una plataforma que permite almacenar c칩digo en la nube de manera que se pueda contribuir de manera colaborativa llevando un control de versiones. Es decir siempre puedes volver a distintos checkpoints de tu c칩digo en caso de introducir un bug y este deje de funcionar como se espera. De esta manera se puede llevar un orden de todos los progresos que se llevan pero sin miedo de romper algo que no se pueda deshacer.  

Github est치 basado en GIT que es el software creado para llevar un control de versiones de un documento. Si bien es cierto GIT se puede utilizar para llevar registro de cualquier tipo de archivo, 칠ste se ha popularizado para el desarrollo de software libre. Hoy en d칤a no se puede ser desarrollador de software sin saber GIT/Github. Es por eso que para la ciencia de datos, que es un campo que cada vez m치s tiene que ver con el desarrollo de software se hace esencial saber lo b치sico y yo dir칤a que un poquito m치s.

![picture of me]({{ site.urlimg }}github/meme_1.jpg){: .center width="250"}

Lamentablemente, son pocos las personas que entienden a cabalidad como funciona GIT. Y como al final tiene tantos comandos (que muchas veces hay que correr en terminal), mucha gente le tiene mucho miedo y conoce los comandos b치sicos sin entenderlos. Incluso desarrolladores con mucha experiencia no llegan a entenderlo bien.

![picture of me]({{ site.urlimg }}github/meme_2.jpg){: .center}

Con esto no quiero decir que har칠 una clase magistral de c칩mo usarlo, pero al menos tener la intuici칩n m치s avanzada. No soy experto en GIT pero ya lo entiendo a un nivel que no me da miedo pensar que dejar칠 la embarrada y no podr칠 solucionarlo.

Bueno, entonces 쯖칩mo usamos GIT? Yo creo que est치 lleno de tutoriales de c칩mo aprender a usarlo. Pero creo que lo mejor es entender c칩mo funciona con un ejemplo. Para ello voy a crear un Repositorio desde cero y mostrar c칩mo se trabaja con 칠l.

{% include alert tip='Puedes seguir este [Repo](https://github.com/datacubeR/tutorial_github) en el cual llev칠 a cabo todos los pasos mostrados.'%}

## Creando un Repo en Github.

Primero que todo tenemos que ir a nuestro perfil de Github y tenemos la opci칩n de crear un Nuevo Repositorio:

![picture of me]({{ site.urlimg }}github/new_repo.png){: .center}

En este caso este es mi p치gina de inicio, y si se escoge la pesta침a *Repositories* y clickeas en *New*, se llega a algo como esto:

![picture of me]({{ site.urlimg }}github/repo_2.png){: .center}

Cuando se es primera vez que se trabaja con Github, mi recomendaci칩n es s칩lo colocar el nombre (en este caso *tutorial_github*, dejarlo como un Repo P칰blico y clickear en *Create repository*). La raz칩n por la cual hacer esto es porque si se no se escoge nada para comenzar el repositorio el propio Github te entrega instrucciones de c칩mo continuar con el proceso. 

{% include alert warning='Cuando un Repositorio es p칰blico implica que cualquier persona puede verlo. En caso de que haya c칩digo que no quieres que sea compartido con alguien m치s, entonces mi recomendaci칩n es dejarlo privado.' %}

![picture of me]({{ site.urlimg }}github/new_repo3.png){: .center}

Al terminar la construcci칩n del Repo nos entrega instrucciones a seguir para continuar con el proceso. Lo que acabamos de hacer es crear nuestro Repo Remoto, lo cual normalmente Github llama **origin**. Nuestro Repo remoto va a ser el backup que va a vivir en la Nube, espec칤ficamente en Github. Este remoto por s칤 solo no es 칰til, este debe ser sincronizado con nuestro Repo Local. Y un Repo Local no es m치s que una manera fancy de denominar una carpeta de nuestro computador. La diferencia es que esta carpeta va a ir siendo trackeada, y se guardaran todas las distintas versiones que nosotros queramos de nuestros documentos.

El control de versiones nos permitir치 evitar carpetas llenas de m칰ltiples copias de nuestro trabajo como esto:

![picture of me]({{ site.urlimg }}github/version_control.png){: .center}

{% include alert tip='A continuaci칩n voy a ir mostrando el paso a paso en mi maquina con Ubuntu. Seguir estos pasos es exactamente igual en los distintos sistemas operativos. La ventaja de usar Ubuntu y en mi caso el Shell ZSH es que tiene algunos elementos que me ayudar치n a entender mejor el estado de mi Repo.'%}


# Creando Nuestro Repo Local


Crear nuestro Repo Local es muy sencillo, s칩lo tienes que asegurarte de tener instalado GIT desde [ac치](https://git-scm.com/downloads). Y en la carpeta de inter칠s abre la l칤nea de comandos y ejecuta:

```shell
$ git init
```

{% include alert info='El comando `git init` lo 칰nico que hace es crear una carpeta oculta llamada `.git` que lo que har치 es ir almacenando autom치ticamente distintas versiones de tus documentos. '%}


Ahora nuestro Repo Local es la carpeta de trabajo que utilizaremos y se crea autom치ticamente la Rama Master que es como la versi칩n oficial en la que trabajaremos:

![picture of me]({{ site.urlimg }}github/git_init.png){: .center}

{% include alert info='Para seguir los comandos en Windows mi recomendaci칩n es usar Git Bash. Este es un shell que se instalar치 junto con GIT.'%}

Pero para que este repo local, se sincronice con el Repo Remoto que tenemos en Github tenemos que ejecutar lo siguiente:

```shell
$ git remote add origin git@github.com:datacubeR/tutorial_github.git
```
donde `git@github.com:datacubeR/tutorial_github.git` corresponde a la localizaci칩n de nuestro Repo Remoto. Github ofrece dos versiones para la localizaci칩n del Repo: HTTPS y SSH. Mi recomendaci칩n es ir por la SSH ya que poco a poco Github est치 quitando soporte a la HTTPS. Adem치s la versi칩n SSH permite que cada vez que hagas commit y push no tengas que colocar tu clave de acceso, lo cual lo hace muy c칩modo y de hecho es m치s seguro.

Si te interesa configurar Github con SSH te recomiendo el siguiente tutorial:

<div class='embed-youtube'>
{% include youtubePlayer.html id="Z3ELWci34cM" %}
</div>

<br>

# Esquema de trabajo en Github

Es tan popular el uso de Github que se han desarrollado distintas estrategias de trabajo para trabajar en 칠l. Yo tuve la suerte de trabajar en [Jooycar](https://www.jooycar.com/), que segu칤a bastantes buenas pr치cticas de desarrollo de software y pude aprender (siento que) bastante bien c칩mo trabajar con Github. 

![picture of me]({{ site.urlimg }}github/gitflow.png){: .center}

B치sicamente la idea es seguir una l칩gica de Ramas, donde la Rama Master (recientemente renombrada main, pero yo y la mayor칤a sigue llamandola Master, porque suena m치s cool) es la versi칩n principal de tu c칩digo. La idea que el c칩digo que vive en Master sea el c칩digo funcional, libre de bugs. Y cualquier trabajo se haga en ramas paralelas que no rompan Master. Una vez que las ramas paralelas (o de features) est칠n probadas y se sabe que funcionan como se esperan, se unir치n a Master. 
En Github hay harta terminolog칤a que es importante entender antes de usarlo:

* **Ramas**: Son las distintas versiones del trabajo realizado. La rama principal es Master o Main.
* **Ramas Secundarias**: Versiones donde se realizan las pruebas y desarrollo nuevo para evitar romper Master.
* **Commits**: Corresponden a cada uno de los puntitos. Cada punto es un **Save**. Es decir por cada commits hay cambios en el c칩digo, pueden ser adiciones, sustracciones o modificaciones del c칩digo.
* **Push**: Se refiere a guardar nuestros commits locales en Github (en remoto).

{% include alert warning='Es importante que el tener una versi칩n remota no es s칩lo para tener un respaldo en caso de que algo pase con tu maquina local, sino que para que todos tus compa침eros puedan tener acceso al c칩digo. De esa manera se evitan esas malas pr치cticas de enviar un Notebook/Script por Slack o de copiar y pegar una l칤nea de c칩digo.' %}

# Nuestro Primer Commit

Para realizar el commit entonces es necesario hacer nuestros primeros cambios: Creemos entonces un archivo llamado `main.py` y creemos lo siguiente:

```python
import pandas as pd
import numpy as np

def detectar_nulos(df):
    return df.isnull().sum()

```
{: title="main.py"}

Luego entonces debemos utilizar los siguientes comandos:

```shell
$ git add .
```
Este comando agregar치 todos los archivos (punto equivale a todos los archivos en la carpeta actual) al <mark>Stage Area</mark>. Esta 치rea se utiliza para indicarle a git cu치les son los archivos que van a ser parte del commit. Obviamente no es necesario juntarlos todos, pero es lo m치s com칰n. Tambi칠n se puede usar **git add** para ir agreg치ndo s칩lo los necesarios (pero normalmente todos los archivos modificados son parte del commit).

```shell
$ git status
```

**git status** nos dir치 cuales son los archivos que est치n actualmente siendo trackeados.

```shell
$ git commit -m 'Mi primer Commit'
```
Finalmente **git commit** ser치 el encargado de guardar una versi칩n en GIT. Esta versi칩n va a acompa침ada de un mensaje, el que indica en qu칠 se trabaj칩 durante dicho commit. De esta manera en caso de tener errores en el futuro y se quiera volver a versiones anteriores se tiene el comentario como referencia para encontrar el commit indicado.

## Nuestro Primer Push

Para llevar el c칩digo a Github es necesario hacer un push:

```shell
$ git push
```

Es importante entender que este comando fallar치 la primera vez que se ejecute ya que GIT inicialmente no entiende con qu칠 ramas remotas est치 sincronizado. Mi recomendaci칩n es que usar **git push**. Al fallar, Github indicar치 que no es el comando indicado (normalmente se agregan el nombre de la rama y unos flags) y te dir치 cu치l es el apropiado. Esto se debe hacer en el primer commit de cada rama. Luego de eso git push es suficiente.

Todos nuestros cambios se ven en Github de la siguiente forma:

![picture of me]({{ site.urlimg }}github/push.png){: .center}


{% include alert success='Normalmente esto es casi todo lo que cualquier persona que dice saber GIT efectivamente sabe. Quiz치s algunos dicen conocer git pull. Pero la verdad es que eso no es del todo cierto y voy a explicar git pull en detalle m치s adelante.'%}

# Trabajo en Ramas

Si bien es cierto siempre se puede ir trabajando en Master, esto constituye una muy mala pr치ctica. Como hemos dicho anteriormente, se considera Master como la versi칩n productiva del c칩digo. Por lo tanto, no puede ser alterado por nada que no sea por c칩digo debidamente probado. En el caso de trabajar en cualquier cosa que pudiera romper el c칩digo productivo (esto significa b치sicamente todo lo que no sea el c칩digo final), es necesario trabajar en Ramas.

```shell
$ git checkout -b nueva-rama
```

Este comando crear치 una nueva rama e inmediatamente se cambiar치 a ella. El flag `-b` es para indicar que la rama creada se llamar치 `nueva-rama`. Existen varias convenciones para el nombramiento de las nuevas ramas, normalmente se antepone un `feature` cuando se est치 trabajando en una nueva funcionalidad del c칩digo o `hot-fix` cuando se quiere solucionar r치pidamente un bug encontrado en producci칩n. Pero la verdad la convenci칩n de nombres va a depender del equipo. Lo importante es que el nombre de la rama sea representativo del trabajo realizado.

La rama corresponde a una versi칩n paralela del c칩digo. Las buenas pr치cticas dicen que las nuevas ramas debieran salir principalmente de Master, pero siempre se pueden crear subramas que partan del trabajo realizado de un compa침ero. Entre m치s anidadas est칠n las ramas m치s complicado es volver a unirla en Master, por lo que si bien, es posible, se desaconseja en la medida de lo posible.

Al crear una rama, todo funciona igual, salvo que los commits se ir치n haciendo en la nueva rama, creando una historia alternativa a Master. En este caso cuando queramos hacer un push tendremos que definir la primera vez cuales es la rama correspondiente en Github.

Por ejemplo, supongamos una rama en la cual ahora creamos una segunda funci칩n:

![picture of me]({{ site.urlimg }}github/main_2.png){: .center}

Podemos actualizar nuestro Repo utilizando los comandos vistos anteriormente:

```shell
$ git add .
$ git commit -m 'Mi primer Commit en otra Rama'
$ git push --set-upstream origin nueva-rama
```

El resultado se ver치 en Github as칤:

![picture of me]({{ site.urlimg }}github/push_otra_rama.png){: .center}


Apenas creemos un nuevo commit en una rama no Master, Github nos sugerir치 que realicemos un Pull Request (PR para los amigos). Entender un Pull Request y todas las funcionalidades que tiene da para un art칤culo entero, pero en sencillo, un Pull Request es una instancia de revisi칩n, en la que normalmente un Programador/Data Scientist con m치s experiencia, revisar치 el c칩digo (aunque tambi칠n puede ser un par). De esta manera varios pares de ojos revisan que:

* No se introduzcan bugs a la rama productiva.
* Pueden sugerir mejores manera de abordar una soluci칩n.
* Pueden corregir y dar feedback del trabajo realizado.

Al crear el PR se debe colocar un t칤tulo adhoc al trabajo realizado m치s una descripci칩n. El PR tiene la posibilidad de ser comentado (para sugerir feedback), aprobado directamente en caso de no tener problemas, o se pueden solicitar cambios que deben ser realizados antes de la aprobaci칩n. En caso de que el PR no sea aprobado no podr치 fusionarse con Master (en estricto rigor los settings por defecto de Github te dejan hacer el merge, pero no se deber칤a). 

{% include alert info='En cualquier caso Github permite bloquear los push a Master permiti칠ndolos s칩lo mediante PRs aprobados, esta funcionalidad est치 disponible en todos los Repos P칰blicos, o en Repos Privados que sean Cuenta Pro o Enterprise'%}

# Realizando un Pull Request

Un Pull Request es una instancia iterativa de revisi칩n. No es necesario abrir el PR cuando el trabajo est치 listo. De hecho, es mejor abrirlo apenas se comience con el trabajo. De esa manera los DS con m치s experiencia pueden ir mirando tu c칩digo sin necesidad de tener que agendar una reuni칩n. De hecho, puedes pedir feedback, sugerencias, opiniones, etc.

Una vez abierto un Pull Request puedes seguir a침adiendo commits con cada uno de los avances que vayas haciendo. Si seguimos el ejemplo, lo primero que debemos hacer es abrir el Pull Request. Se puede clickear directamente en el Compare & pull request o ir a la pesta침a Pull Request y clickear en New Pull Request.

![picture of me]({{ site.urlimg }}github/PR.png){: .center}

Como se puede ver, el PR se puede crear al clickear abajo. Esto significa que est치 listo para ser revisado. Pero adem치s para Repos P칰blicos o Empresa, se tiene la opci칩n Draft. Esto quiere decir que est치 en progreso. Y si bien se puede mirar el c칩digo y el progreso, no est치 listo para ser aprobado.

![picture of me]({{ site.urlimg }}github/PR_2.png){: .center}

En este caso hice el PR como Draft, lo cual quiere decir que a칰n no est치 listo para ser revisado como se indica abajo. Adicionalmente Github permite colocar Reviewers, Labels, Proyectos e incluso Issues que permiten llevar mejor control del trabajo a realizar.

Entonces, siguiendo con el ejemplo el PR dice que haremos dos funciones. Nos falta una, la cual crearemos:

![picture of me]({{ site.urlimg }}github/main_3.png){: .center}


```shell
$ git add .
$ git commit -m 'Agrego la segunda funci칩n del PR'
$ git push
```

Suponiendo que ahora est치 listo el trabajo a realizar, pidamos entonces que el PR pase a revisi칩n. Para ello clickeamos en Ready for Review y podemos asignar a alguien para revisi칩n o pedirle de manera particular. Para ello el revisor debe ir a la pesta침a **Files Changed** y se encontrar치 con algo as칤:

![picture of me]({{ site.urlimg }}github/PR_3.png){: .center}

Al revisar podemos ir linea por l칤nea agregando comentarios, o podemos agregar sugerencias como se ve en la l칤nea 10-12. De esa manera, la persona puede s칩lo aceptar la sugerencia y hacer commit directamente, en vez de tener que realizar todo el cambio y volver a agregar el commit desde su Repo Local.

![picture of me]({{ site.urlimg }}github/PR_4.png){: .center}

Al terminar la revisi칩n se puede hacer click en Finish your review, y se tienen 3 opciones:

![picture of me]({{ site.urlimg }}github/PR_5.png){: .center}

* **Comment**: Permite dar feedback.
* **Approve**: Indica que el c칩digo est치 correcto y listo para hacer merge.
* **Request Changes**: Implica que el c칩digo est치 incorrecto y no se va a aprobar hasta que se solucionen los comentarios dejados.

Una vez que el PR est칠 listo basta con cerrarlo haciendo Merge con Master:

![picture of me]({{ site.urlimg }}github/PR_6.png){: .center}

Como se puede ver, acept칠 una de las sugerencias hechas en el PR, por lo tanto mi origin/master final queda de la siguiente manera:

![picture of me]({{ site.urlimg }}github/merge.png){: .center}

Tenemos las 3 funciones que nos interesan.

# Sincronizaci칩n del Repo Remoto con el Repo Local

Es com칰n que varias personas trabajen en paralelo en un mismo proyecto. Por lo tanto puede pasar que distintos Data Scientist trabajen en distintos aspectos de dicho proyecto. Adem치s como dijimos, todos los cambios tienen que ir haci칠ndose siempre en origin/master (la versi칩n remota de master). Pero eso no necesariamente va a estar en nuestro computador local. Por lo tanto, debemos asegurarnos que tengamos nuestro master local al d칤a. La mayor칤a utiliza **git pull** para hacer esto. Y no hay nada de malo, pero...

쯉ab칤as que hay dos estrategias de Pull, y es muy probable que la estrategia por defecto no sea la mejor para ti?

Si no quieres pensar nada, y no te interesa entender qu칠 pasa en GIT usa git pull y no te cuestiones nada. Pero existe una segunda estrategia que se llama Rebase, que diferencia un usuario com칰n de uno que entiende un poquito m치s de GIT.

`git pull` es un comando compuesto, es la mezcla entre un git fetch + git merge o git rebase dependiendo de c칩mo lo uses. `git fetch` b치sicamente le dice a Github dime qu칠 tan diferente eres a lo que to tengo en mi Repo Local. Y en caso de que existan diferencias descarga esas diferencias y 칰nelas en mi repo local. Ahora, para descargar esas diferencias hay dos posibilidades: una es usar `git merge`, que b치sicamente crea un commit extra (lo cual ensucia un poco Master ya que cada vez que exista un pull, voy a crear un commit m치s que la mayor칤a de las veces solo estorba en la historia del c칩digo). Existe una segunda alternativa que es `git rebase`. El cual se le conoce como ser un comando malvado que puede destruir tu c칩digo, pero la verdad es que si se entiende bien no hay nada que temer.

![picture of me]({{ site.urlimg }}github/rebase_meme.jpg){: .center}


B치sicamente lo que hace un Rebase es: toma tu rama y hace que comience al final de Master (o de la rama que t칰 desees), es decir, cambia la base (el punto de partida) al final de la rama especificada. Esto es 칰til no s칩lo para actualizar el Repo pero tambi칠n para poder utilizar los cambios realizados en tu nueva rama.

En nuestro caso entonces, alguien hizo cambios en la rama nueva-rama y adem치s acept칩 la sugerencia de uno de los revisores durante el PR. Esto quiere decir que ninguno de estos cambios est치 actualizado en en nuestro repo local. Para ello entonces haremos:

```shell 
$ git pull --rebase
```
{% include alert alert='El comando anterior debe hacerse en la rama base donde se pegaran los cambios, es decir, en nuestro caso primero hay que moverse a Master (git checkout master) y luego el git pull --rebase'%}

Notar que se genera lo siguiente:

![picture of me]({{ site.urlimg }}github/rebase.png){: .center}

* origin/master que es la rama nueva se crea a continuaci칩n de Master, sin crear un commit extra. 
* origin/master considera el merge de origin-nueva-rama que es la versi칩n remota resultado del PR.

Podemos ver que ahora en nuestro Master Local tenemos lo mismo que en Github:

![picture of me]({{ site.urlimg }}github/rebase_2.png){: .center}

## El temido conflicto

Supongamos ahora que hay otra rama llamada otro-usuario, que es el trabajo que otro DS est치 haciendo y que como se pudo ver anteriormente no incluye los cambios de origin/master (por ejemplo la sugerencia de c칩digo) ya que nace antes del merge.

El avance de este DS es el siguiente:

![picture of me]({{ site.urlimg }}github/rebase_3.png){: .center}

En un error de comunicaci칩n el nuevo DS modific칩 la segunda funci칩n y la llam칩 `calcular_media`. Adem치s cre칩 una tercera funci칩n llamada `calcular_info` que al parecer es m치s completa que `calcular_tipos`.

Entonces pasa de que quiero incluir esos cambios en mi rama. Es decir, quiero que mi rama (otro-usuario) comience luego de origin/master. En este caso haremos uso del rebase, pero no de git fetch (por lo tanto no usamos `git pull --rebase`). Por lo tanto haremos lo siguiente:

```shell
$ git checkout otro-usuario
$ git rebase origin/master
```

Lo que acabamos de hacer es cambiarnos a otro-usuario y decirle quiero que esta rama parta luego de origin/master. Si hacemos esto nos aparece el temido conflicto de GIT:

```shell
First, rewinding head to replay your work on top of it...
Applying: Agrego funcion media
Using index info to reconstruct a base tree...
M       main.py
Falling back to patching base and 3-way merge...
Auto-merging main.py
CONFLICT (content): Merge conflict in main.py
error: Failed to merge in the changes.
Patch failed at 0001 Agrego funcion media
hint: Use 'git am --show-current-patch' to see the failed patch
Resolve all conflicts manually, mark them as resolved with
"git add/rm <conflicted_files>", then run "git rebase --continue".
You can instead skip this commit: run "git rebase --skip".
To abort and get back to the state before "git rebase", run "git rebase --abort".
```

![picture of me]({{ site.urlimg }}github/meme.png){: .center}


Tranquilo, porque un conflicto no es m치s que un malentendido. Ocurre cuando GIT no sabe qu칠 hacer, y decide preguntarte a ti como programador qu칠 c칩digo dejar y qu칠 c칩digo no. Existen muchos add-ons para trabajar con conflictos. En mi opini칩n lo m치s sencillo es usar VSCode (espero que como Data Scientist lo uses ya que permite usar git, notebooks, scripts y montones de add-ins super 칰tiles para programar mejor).

Si es que abres el archivo en cuestion (en nuestro caso el archivo en conflicto es main.py) en VSCode, o en su defecto hiciste el `git rebase` en la consola integrada de VSCode, ver치s algo as칤:

![picture of me]({{ site.urlimg }}github/conflict.png){: .center}

VSCode te deja solucionar el conflicto con un click. Basta con aceptar el Current Change en verde, o el Incoming Change en Azul.

{% include alert info='Rebase generar치 a lo m치s <mark>N</mark> conflictos, donde <mark>N</mark> es el n칰mero de commits que tiene la rama a cambiar de base. Luego de solucionar cada conflicto se debe continuar el rebase usando `git rebase --continue`'%}

Usando `git status` es posible ver lo siguiente:

![picture of me]({{ site.urlimg }}github/conflict_2.png){: .center}

Nos indica que estamos en medio de un rebase. Y en mi caso, debido a que tengo ZSH, me dice que estoy en el primero de dos pasos de un Conflicto. Por lo tanto, en mi caso voy a aceptar el Incoming Change y guardar. Esto porque es el nombre nuevo que me gustar칤a que prevaleciera. Para guardar los cambios en GIT hacemos:

```shell
$ git add .
$ git rebase --continue
``` 
Al hacer este cambio, el segundo commit de otro-usuario nos dice, quiz치s se deber칤a agregar la funci칩n `calcular_info`. Por lo tanto, nuevamente voy a aceptar el Incoming Change.

![picture of me]({{ site.urlimg }}github/conflict_3.png){: .center}

Repetimos el procedimiento anterior, guardando los cambios, y usando los comandos mostrados para obtener lo siguiente:

![picture of me]({{ site.urlimg }}github/resultado.png){: .center}

Entonces nuestra rama comienza al final de origin/master. Es importante recalcar, que en este caso desechamos los cambios producidos en el caso anterior, pero eventualmente uno podr칤a querer dejar algunos elementos de la rama. Para eso VSCode permite alterar el archivo de manera manual (como un archivo de texto) sin utilizar los botones. De esa manera almacenamos todos los elementos que nos interesan independiente si vienen de Incoming o Current, de tal manera de hacer commits mixtos rescatando lo mejor de cada rama.

## Otros aspectos importantes de GIT

### README.md

Este es un archivo que puede ir en la ra칤z o en cada carpeta de tu Repo. Es un archivo markdown que normalmente se usa para especificar el contenido del repo. Debido a que utilizar Markdown, el contenido queda bien bonito. En este caso el **README.md** se ve as칤:

![picture of me]({{ site.urlimg }}github/readme.png){: .center}


### El archivo .gitignore

Este archivo es una configuraci칩n de GIT que nos permitir치 no llevar registro de elementos que no nos interesan. Algunos de esos elementos son:

* **data**: GIT no est치 hecho para eso y va a reclamar si se intentan commitear archivos muy grandes. Para llevar registro de data es mejor usar herramientas como DVC.
* **ambientes virtuales**: No es buena idea porque las librer칤as de Python pueden ser pesadas (Por ejemplo Pytorch es 0.5GB+). Si se sugiere un requierements.txt.
* **\_\_pycache\_\_ o .ipynbcheckpoints**: Estos son archivos que se generan al ejecutar scripts o notebooks y no vale la pena trackearlos.

En caso de querer una lista exhaustiva de archivos que no vale la pena trackear en proyectos de Python pueden ir [ac치](https://github.com/github/gitignore/blob/main/Python.gitignore).

## Notebooks

GIT est치 hecho para tracker archivos de texto, y si bien un notebook es un JSON, que sigue siendo texto, tiene mucha basura que impide chequear bien el c칩digo. Es m치s, si dos usuarios ejecutan celdas de manera distinta se puede incluso inducir conflictos. Mi recomendaci칩n es trackearlo, pero s칩lo como respaldo, el contenido del c칩digo debiera ser revisado en scripts.

## 쮺u치ndo Commitear y Pushear?

Esto es medio pol칠mico, porque GIT naci칩 como una herramienta de desarrollo, y la programaci칩n de un Developer y de un Data Scientist no es igual. Mi <mark>Rule of Thumb 游녨</mark> dir칤a:

* Commit cada vez que termines c칩digo funcional (al menos que corra, aunque no est치 la funcionalidad completamente terminada).
* Push al menos una vez al d칤a.
* PR inmediatamente al abrir una rama para que pueda ser revisado. Y esto lo digo no como una estrategia de micro-management, sino para recibir feedback y poder dar hacer preguntas m치s f치ciles.

{% include alert success='Por ejemplo Github permite hacer algo [as칤](https://github.com/datacubeR/tutorial_github/blob/35e681b8add4fdf32da214ab89c5a23201080c7d/main.py#L4-L5):

Ac치 comparto la definici칩n de la funci칩n `detectar_nulos` compartiendo el permalink. De esta manera pueden compartir c칩digo, preguntar por algo en espec칤fico, pedir revisi칩n, sugerencias, etc.'%}

![picture of me]({{ site.urlimg }}github/permalink.png){: .center}

Espero entonces este tutorial sea de ayuda para poder trabajar como corresponde, usando mejores pr치cticas y llevando un mejor orden y control de su c칩digo.

![picture of me]({{ site.urlimg }}github/meme_final.jpg){: .center}


Nos vemos a la otra,

[**Alfonso**]({{ site.baseurl }}/contact/)
























